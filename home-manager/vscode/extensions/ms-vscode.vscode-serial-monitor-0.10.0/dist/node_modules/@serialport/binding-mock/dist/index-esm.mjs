import t from"debug";const e=t("serialport/binding-mock");let r={},i=0;function o(){return new Promise((t=>process.nextTick((()=>t()))))}class s extends Error{constructor(t){super(t),this.canceled=!0}}const n={reset(){r={},i=0},createPort(t,o={}){i++;const s=Object.assign({echo:!1,record:!1,manufacturer:"The J5 Robotics Company",vendorId:void 0,productId:void 0,maxReadSize:1024},o);r[t]={data:Buffer.alloc(0),echo:s.echo,record:s.record,readyData:s.readyData,maxReadSize:s.maxReadSize,info:{path:t,manufacturer:s.manufacturer,serialNumber:`${i}`,pnpId:void 0,locationId:void 0,vendorId:s.vendorId,productId:s.productId}},e(i,"created port",JSON.stringify({path:t,opt:o}))},list:async()=>(e(null,"list"),Object.values(r).map((t=>t.info))),async open(t){var i;if(!t||"object"!=typeof t||Array.isArray(t))throw new TypeError('"options" is not an object');if(!t.path)throw new TypeError('"path" is not a valid port');if(!t.baudRate)throw new TypeError('"baudRate" is not a valid baudRate');const s=Object.assign({dataBits:8,lock:!0,stopBits:1,parity:"none",rtscts:!1,xon:!1,xoff:!1,xany:!1,hupcl:!0},t),{path:n}=s;e(null,`open: opening path ${n}`);const p=r[n];if(await o(),!p)throw new Error(`Port does not exist - please call MockBinding.createPort('${n}') first`);const h=p.info.serialNumber;if(null===(i=p.openOpt)||void 0===i?void 0:i.lock)throw e(h,"open: Port is locked cannot open"),new Error("Port is locked cannot open");return e(h,`open: opened path ${n}`),p.openOpt=Object.assign({},s),new a(p,s)}};class a{constructor(t,r){if(this.port=t,this.openOptions=r,this.pendingRead=null,this.isOpen=!0,this.lastWrite=null,this.recording=Buffer.alloc(0),this.writeOperation=null,this.serialNumber=t.info.serialNumber,t.readyData){const r=t.readyData;process.nextTick((()=>{this.isOpen&&(e(this.serialNumber,"emitting ready data"),this.emitData(r))}))}}emitData(t){if(!this.isOpen||!this.port)throw new Error("Port must be open to pretend to receive data");const r=Buffer.isBuffer(t)?t:Buffer.from(t);e(this.serialNumber,"emitting data - pending read:",Boolean(this.pendingRead)),this.port.data=Buffer.concat([this.port.data,r]),this.pendingRead&&(process.nextTick(this.pendingRead),this.pendingRead=null)}async close(){if(e(this.serialNumber,"close"),!this.isOpen)throw new Error("Port is not open");const t=this.port;if(!t)throw new Error("already closed");t.openOpt=void 0,t.data=Buffer.alloc(0),e(this.serialNumber,"port is closed"),this.serialNumber=void 0,this.isOpen=!1,this.pendingRead&&this.pendingRead(new s("port is closed"))}async read(t,r,i){if(!Buffer.isBuffer(t))throw new TypeError('"buffer" is not a Buffer');if("number"!=typeof r||isNaN(r))throw new TypeError(`"offset" is not an integer got "${isNaN(r)?"NaN":typeof r}"`);if("number"!=typeof i||isNaN(i))throw new TypeError(`"length" is not an integer got "${isNaN(i)?"NaN":typeof i}"`);if(t.length<r+i)throw new Error("buffer is too small");if(!this.isOpen)throw new Error("Port is not open");if(e(this.serialNumber,"read",i,"bytes"),await o(),!this.isOpen||!this.port)throw new s("Read canceled");if(this.port.data.length<=0)return new Promise(((e,o)=>{this.pendingRead=s=>{if(s)return o(s);this.read(t,r,i).then(e,o)}}));const n=this.port.maxReadSize>i?i:this.port.maxReadSize,a=this.port.data.slice(0,n).copy(t,r);return this.port.data=this.port.data.slice(n),e(this.serialNumber,"read",a,"bytes"),{bytesRead:a,buffer:t}}async write(t){if(!Buffer.isBuffer(t))throw new TypeError('"buffer" is not a Buffer');if(!this.isOpen||!this.port)throw e("write","error port is not open"),new Error("Port is not open");if(e(this.serialNumber,"write",t.length,"bytes"),this.writeOperation)throw new Error("Overlapping writes are not supported and should be queued by the serialport object");return this.writeOperation=(async()=>{if(await o(),!this.isOpen||!this.port)throw new Error("Write canceled");const r=this.lastWrite=Buffer.from(t);this.port.record&&(this.recording=Buffer.concat([this.recording,r])),this.port.echo&&process.nextTick((()=>{this.isOpen&&this.emitData(r)})),this.writeOperation=null,e(this.serialNumber,"writing finished")})(),this.writeOperation}async update(t){if("object"!=typeof t)throw TypeError('"options" is not an object');if("number"!=typeof t.baudRate)throw new TypeError('"options.baudRate" is not a number');if(e(this.serialNumber,"update"),!this.isOpen||!this.port)throw new Error("Port is not open");await o(),this.port.openOpt&&(this.port.openOpt.baudRate=t.baudRate)}async set(t){if("object"!=typeof t)throw new TypeError('"options" is not an object');if(e(this.serialNumber,"set"),!this.isOpen)throw new Error("Port is not open");await o()}async get(){if(e(this.serialNumber,"get"),!this.isOpen)throw new Error("Port is not open");return await o(),{cts:!0,dsr:!1,dcd:!1}}async getBaudRate(){var t;if(e(this.serialNumber,"getBaudRate"),!this.isOpen||!this.port)throw new Error("Port is not open");if(await o(),!(null===(t=this.port.openOpt)||void 0===t?void 0:t.baudRate))throw new Error("Internal Error");return{baudRate:this.port.openOpt.baudRate}}async flush(){if(e(this.serialNumber,"flush"),!this.isOpen||!this.port)throw new Error("Port is not open");await o(),this.port.data=Buffer.alloc(0)}async drain(){if(e(this.serialNumber,"drain"),!this.isOpen)throw new Error("Port is not open");await this.writeOperation,await o()}}export{s as CanceledError,n as MockBinding,a as MockPortBinding};