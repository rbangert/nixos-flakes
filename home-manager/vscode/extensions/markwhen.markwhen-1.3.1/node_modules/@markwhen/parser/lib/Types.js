"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = exports.emptyTimeline = exports.Event = exports.toDateRange = exports.toDateRangeIso = exports.RangeType = exports.EventDescription = exports.Image = exports.Block = exports.BlockType = exports.AT_REGEX = exports.IMAGE_REGEX = exports.LOCATION_REGEX = exports.LINK_REGEX = exports.DateRangePart = exports.RelativeDate = exports.DATE_TIME_FORMAT_YEAR = exports.DATE_TIME_FORMAT_MONTH_YEAR = exports.EUROPEAN_DATE_FORMAT = exports.AMERICAN_DATE_FORMAT = void 0;
const luxon_1 = require("luxon");
const Node_1 = require("./Node");
const regex_1 = require("./regex");
const html_1 = require("./utilities/html");
exports.AMERICAN_DATE_FORMAT = "M/d/y";
exports.EUROPEAN_DATE_FORMAT = "d/M/y";
exports.DATE_TIME_FORMAT_MONTH_YEAR = "M/y";
exports.DATE_TIME_FORMAT_YEAR = "y";
class RelativeDate {
    static from(raw, priorDate, before = false) {
        const matches = raw.matchAll(regex_1.AMOUNT_REGEX);
        let match = matches.next();
        const plusOrMinus = before ? "minus" : "plus";
        while (match.value) {
            const value = match.value;
            const amount = parseInt(value[1]);
            if (value[3]) {
                priorDate = priorDate[plusOrMinus]({ milliseconds: amount });
            }
            else if (value[4]) {
                priorDate = priorDate[plusOrMinus]({ seconds: amount });
            }
            else if (value[5]) {
                priorDate = priorDate[plusOrMinus]({ minutes: amount });
            }
            else if (value[6]) {
                priorDate = priorDate[plusOrMinus]({ hours: amount });
            }
            else if (value[7]) {
                priorDate = before
                    ? removeWeekdays(amount, priorDate)
                    : addWeekdays(amount, priorDate);
            }
            else if (value[8]) {
                priorDate = priorDate[plusOrMinus]({ days: amount });
            }
            else if (value[9]) {
                priorDate = priorDate[plusOrMinus]({ weeks: amount });
            }
            else if (value[10]) {
                priorDate = priorDate[plusOrMinus]({ months: amount });
            }
            else if (value[11]) {
                priorDate = priorDate[plusOrMinus]({ years: amount });
            }
            match = matches.next();
        }
        return priorDate;
    }
}
exports.RelativeDate = RelativeDate;
function removeWeekdays(amount, fromDate) {
    const currentWeekday = fromDate.weekday - 1;
    const lessThisWeek = amount - currentWeekday;
    if (lessThisWeek <= 0) {
        // We have enough this week, just subtract the days
        return fromDate.minus({ days: amount });
    }
    const numDaysInWeekend = 2;
    const numDaysInWeek = 7;
    const numWorkDaysInWeek = 5;
    const firstWeek = currentWeekday;
    const weeks = ~~(lessThisWeek / numWorkDaysInWeek);
    const remainder = lessThisWeek % numWorkDaysInWeek;
    const days = weeks * numDaysInWeek;
    const lastWeek = remainder ? numDaysInWeekend + remainder : 0;
    return fromDate.minus({ days: firstWeek + days + lastWeek });
}
function addWeekdays(amount, toDate) {
    const currentWeekday = toDate.weekday;
    const saturday = 6;
    const thisWeek = saturday - currentWeekday;
    const lessThisWeek = amount - thisWeek;
    if (lessThisWeek <= 0) {
        // We have enough this week, just add the days
        return toDate.plus({ days: amount });
    }
    else {
        const numDaysInWeekend = 2;
        const numDaysInWeek = 7;
        const numWorkDaysInWeek = 5;
        const firstWeek = thisWeek;
        const weeks = ~~(lessThisWeek / numWorkDaysInWeek);
        const remainder = lessThisWeek % numWorkDaysInWeek;
        // Get up through Friday
        const days = weeks * numDaysInWeek;
        // If there's a remainder, add the last weekend back
        const lastWeek = remainder ? numDaysInWeekend + remainder : 0;
        return toDate.plus({ days: firstWeek + days + lastWeek });
    }
}
class DateRangePart {
    constructor(fromDateTime, toDateTime, originalString, dateRangeInText, eventText, recurrence) {
        this.fromDateTime = fromDateTime;
        this.toDateTime = toDateTime;
        this.originalString = originalString;
        this.dateRangeInText = dateRangeInText;
        this.eventText = eventText;
        this.recurrence = recurrence?.recurrence;
        this.recurrenceRangeInText = recurrence?.range;
    }
}
exports.DateRangePart = DateRangePart;
exports.LINK_REGEX = /\[([^\]\<\>]+)\]\(((https?:\/\/)?[\w\d./\&\?=\-#:,_]+)\)/g;
exports.LOCATION_REGEX = /\[([^\]]+)\]\((location|map)\)/g;
exports.IMAGE_REGEX = /!\[([^\]\<\>]*)\]\(((https?:\/\/)?[\w\d./\&\?=\-#:,_]+)\)/;
exports.AT_REGEX = /@([\w\d\/]+)/g;
const PERCENT_REGEX = /(?:\s|^)(\d{1,3})%(?:\s|$)/;
var BlockType;
(function (BlockType) {
    BlockType["TEXT"] = "text";
    BlockType["LIST_ITEM"] = "listItem";
    BlockType["CHECKBOX"] = "checkbox";
    BlockType["IMAGE"] = "image";
})(BlockType = exports.BlockType || (exports.BlockType = {}));
class Block {
    constructor(raw) {
        this.raw = raw;
        if (raw.startsWith("- []")) {
            this.type = BlockType.CHECKBOX;
            this.value = false;
            this.raw = raw.substring(4).trim();
        }
        else if (raw.startsWith("- [ ]")) {
            this.type = BlockType.CHECKBOX;
            this.value = false;
            this.raw = raw.substring(5).trim();
        }
        else if (raw.startsWith("- [x]")) {
            this.type = BlockType.CHECKBOX;
            this.value = true;
            this.raw = raw.substring(5).trim();
        }
        else if (raw.startsWith("- ")) {
            this.type = BlockType.LIST_ITEM;
            this.raw = raw.substring(2);
        }
        else {
            this.type = BlockType.TEXT;
        }
    }
}
exports.Block = Block;
class Image {
    constructor(altText, link) {
        this.type = "image";
        this.altText = altText;
        this.link = link;
    }
}
exports.Image = Image;
class EventDescription {
    constructor(lines, matchedListItems, completed) {
        this.tags = [];
        this.supplemental = [];
        this.locations = [];
        this.matchedListItems = matchedListItems;
        for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            if (line.match(regex_1.COMMENT_REGEX)) {
                continue;
            }
            // only get the image if it's on the first line, others will be scooped up by supplemental
            if (i === 0) {
                line = line.replace(exports.IMAGE_REGEX, (match, altText, link) => {
                    this.supplemental.push(new Image(altText, (0, html_1.addHttpIfNeeded)(link)));
                    return "";
                });
            }
            line = line.replace(exports.LOCATION_REGEX, (match, locationString) => {
                this.locations.push(locationString);
                return "";
            });
            line = line.replace(regex_1.TAG_REGEX, (match, tag) => {
                if (!this.tags.includes(tag)) {
                    this.tags.push(tag);
                }
                return "";
            });
            line = line.replace(regex_1.EVENT_ID_REGEX, (match, id) => {
                if (!this.id) {
                    this.id = id;
                    return "";
                }
                return id;
            });
            if (!this.percent) {
                const percent = line.match(PERCENT_REGEX);
                if (percent) {
                    this.percent = parseInt(percent[0]);
                }
            }
            lines[i] = line;
        }
        this.eventDescription = lines[0];
        this.supplemental = this.supplemental.concat(lines
            .slice(1)
            .filter((l) => !l.match(regex_1.COMMENT_REGEX) && !!l.trim())
            .map((raw) => {
            raw = raw.replace(regex_1.TAG_REGEX, (match, tag) => {
                if (!this.tags.includes(tag)) {
                    this.tags.push(tag);
                }
                return "";
            });
            const image = raw.match(exports.IMAGE_REGEX);
            if (image) {
                return new Image(image[1], (0, html_1.addHttpIfNeeded)(image[2]));
            }
            else {
                return new Block(raw.trim());
            }
        }));
        this.completed = completed;
    }
}
exports.EventDescription = EventDescription;
var RangeType;
(function (RangeType) {
    RangeType["Comment"] = "comment";
    RangeType["CheckboxItemIndicator"] = "checkboxItemIndicator";
    RangeType["listItemIndicator"] = "listItemIndicator";
    RangeType["ListItemContents"] = "listItemContents";
    RangeType["Tag"] = "tag";
    RangeType["tagDefinition"] = "tagDefinition";
    RangeType["Title"] = "title";
    RangeType["View"] = "view";
    RangeType["Viewer"] = "viewer";
    RangeType["Description"] = "description";
    RangeType["Section"] = "section";
    RangeType["DateRange"] = "dateRange";
    RangeType["Event"] = "event";
    RangeType["Edit"] = "edit";
    RangeType["Editor"] = "editor";
    RangeType["Recurrence"] = "recurrence";
})(RangeType = exports.RangeType || (exports.RangeType = {}));
const toDateRangeIso = (dr) => ({
    fromDateTimeIso: dr.fromDateTime.toISO(),
    toDateTimeIso: dr.toDateTime.toISO(),
});
exports.toDateRangeIso = toDateRangeIso;
const toDateRange = (dr) => ({
    fromDateTime: luxon_1.DateTime.fromISO(dr.fromDateTimeIso),
    toDateTime: luxon_1.DateTime.fromISO(dr.toDateTimeIso),
});
exports.toDateRange = toDateRange;
class Event {
    constructor(eventString, dateRange, rangeInText, dateRangeInText, event, dateText) {
        this.eventString = eventString;
        this.eventText = dateRange.eventText;
        this.dateRangeIso = (0, exports.toDateRangeIso)(dateRange);
        this.recurrence = dateRange.recurrence;
        this.recurrenceRangeInText = dateRange.recurrenceRangeInText;
        this.rangeInText = rangeInText;
        this.eventDescription = event;
        this.dateText = dateText;
        this.dateRangeInText = dateRangeInText;
    }
}
exports.Event = Event;
function emptyTimeline() {
    const now = luxon_1.DateTime.now();
    return {
        events: new Node_1.Node([]),
        ranges: [],
        foldables: [],
        tags: {},
        ids: {},
        metadata: {
            earliestTime: now.minus({ years: 5 }).toISO(),
            latestTime: now.plus({ years: 5 }).toISO(),
            maxDurationDays: now.diff(now.minus({ years: 1 })).as("days"),
            dateFormat: exports.AMERICAN_DATE_FORMAT,
            startLineIndex: 0,
            endLineIndex: 0,
            startStringIndex: 0,
            endStringIndex: 0,
            preferredInterpolationFormat: undefined,
            view: [],
            edit: [],
        },
    };
}
exports.emptyTimeline = emptyTimeline;
class Path extends Array {
    static root() {
        return Path.from([0]);
    }
}
exports.Path = Path;
