"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDateRangeFromEDTFRegexMatch = void 0;
const luxon_1 = require("luxon");
const regex_1 = require("../regex");
const Types_1 = require("../Types");
const utils_1 = require("./utils");
const checkRecurrence_1 = require("./checkRecurrence");
function getDateRangeFromEDTFRegexMatch(line, i, lengthAtIndex, context, cache) {
    const eventStartLineRegexMatch = line.match(regex_1.EDTF_START_REGEX);
    if (!eventStartLineRegexMatch) {
        return;
    }
    const datePart = eventStartLineRegexMatch[regex_1.edtfDatePartMatchIndex];
    const edtfFrom = eventStartLineRegexMatch[regex_1.from_edtfDateIndex];
    const edtfFromHasMonth = !!eventStartLineRegexMatch[regex_1.from_edtfDateMonthPart];
    const edtfFromHasDay = !!eventStartLineRegexMatch[regex_1.from_edtfDateDayPart];
    const eventEndDate = eventStartLineRegexMatch[regex_1.to_edtfIndex];
    const edtfTo = eventStartLineRegexMatch[regex_1.to_edtfDateIndex];
    const edtfToHasMonth = !!eventStartLineRegexMatch[regex_1.to_edtfDateMonthPart];
    const edtfToHasDay = !!eventStartLineRegexMatch[regex_1.to_edtfDateDayPart];
    const relativeFromBeforeOrAfter = eventStartLineRegexMatch[regex_1.from_edtfBeforeOrAfterMatchIndex];
    const relativeToBeforeOrAfter = eventStartLineRegexMatch[regex_1.to_edtfBeforeOrAfterMatchIndex];
    const relativeFromDate = eventStartLineRegexMatch[regex_1.from_edtfRelativeMatchIndex];
    const fromBeforeOrAfter = ["before", "by"].includes(relativeFromBeforeOrAfter || "")
        ? "before"
        : "after";
    const relativeToDate = eventStartLineRegexMatch[regex_1.to_edtfRelativeMatchIndex];
    const toBeforeOrAfter = ["before", "by"].includes(relativeToBeforeOrAfter || "")
        ? "before"
        : "after";
    const nowFrom = eventStartLineRegexMatch[regex_1.from_edtfNowMatchIndex];
    const nowTo = eventStartLineRegexMatch[regex_1.to_edtfNowMatchIndex];
    const indexOfDateRange = line.indexOf(datePart);
    const dateRangeInText = {
        type: Types_1.RangeType.DateRange,
        from: lengthAtIndex[i] + indexOfDateRange,
        to: lengthAtIndex[i] + indexOfDateRange + datePart.length,
        lineFrom: {
            line: i,
            index: indexOfDateRange,
        },
        lineTo: {
            line: i,
            index: indexOfDateRange + datePart.length,
        },
    };
    context.ranges.push(dateRangeInText);
    const colonIndex = line.indexOf(":", indexOfDateRange + datePart.length);
    const colonRange = (rangeType) => ({
        type: rangeType,
        from: lengthAtIndex[i] + colonIndex,
        to: lengthAtIndex[i] + colonIndex + 1,
        lineFrom: {
            line: i,
            index: colonIndex,
        },
        lineTo: {
            line: i,
            index: colonIndex + 1,
        },
    });
    const cached = cache?.ranges.get(datePart);
    if (cached) {
        const recurrence = (0, checkRecurrence_1.checkEdtfRecurrence)(eventStartLineRegexMatch, lengthAtIndex, i);
        if (recurrence) {
            context.ranges.push(recurrence.range);
            context.ranges.push(colonRange(Types_1.RangeType.Recurrence));
        }
        else {
            context.ranges.push(colonRange(Types_1.RangeType.DateRange));
        }
        const dateRange = new Types_1.DateRangePart(luxon_1.DateTime.fromISO(cached.fromDateTimeIso), luxon_1.DateTime.fromISO(cached.toDateTimeIso), datePart, dateRangeInText, eventStartLineRegexMatch[regex_1.edtfEventTextMatchIndex], recurrence);
        return dateRange;
    }
    let fromDateTime;
    let endDateTime;
    let granularity = "instant";
    let canCacheRange = true;
    if (edtfFrom) {
        fromDateTime = luxon_1.DateTime.fromISO(edtfFrom);
        granularity = edtfFromHasDay ? "day" : edtfFromHasMonth ? "month" : "year";
    }
    else if (relativeFromDate) {
        // Dependent on other event
        canCacheRange = false;
        const relativeToEventId = eventStartLineRegexMatch[regex_1.from_edtfRelativeEventIdMatchIndex];
        let relativeTo = relativeToEventId &&
            (fromBeforeOrAfter === "after"
                ? context.ids[relativeToEventId]
                    ? (0, Types_1.toDateRange)(context.ids[relativeToEventId].dateRangeIso).toDateTime
                    : undefined
                : context.ids[relativeToEventId]
                    ? (0, Types_1.toDateRange)(context.ids[relativeToEventId].dateRangeIso).fromDateTime
                    : undefined);
        if (!relativeTo) {
            const priorEvent = (0, utils_1.getPriorEvent)(context);
            if (!priorEvent) {
                relativeTo = context.now;
            }
            else {
                relativeTo =
                    fromBeforeOrAfter === "after"
                        ? (0, Types_1.toDateRange)(priorEvent.dateRangeIso).toDateTime
                        : (0, Types_1.toDateRange)(priorEvent.dateRangeIso).fromDateTime;
            }
        }
        if (!relativeToDate && !eventEndDate) {
            // We don't have an end date set. Instead of using the relative
            // from date to determine the start time, we're going to use
            // the end time of the previous event as the start and make the
            // duration the provided relative time.
            if (fromBeforeOrAfter === "before") {
                // In the case of this being a 'before' relative date, the
                // end date is relativeTo and the start date is `amount` before it.
                endDateTime = relativeTo;
                fromDateTime = Types_1.RelativeDate.from(relativeFromDate, relativeTo, true);
            }
            else {
                fromDateTime = relativeTo;
                endDateTime = Types_1.RelativeDate.from(relativeFromDate, relativeTo);
            }
        }
        else {
            if (fromBeforeOrAfter === "before") {
                if (relativeToDate) {
                    // in this case we're actually determining the end dateTime, with its duration,
                    // or start time, to be figured out from the eventEndDate
                    endDateTime = Types_1.RelativeDate.from(relativeFromDate, relativeTo, true);
                    fromDateTime = Types_1.RelativeDate.from(relativeToDate, endDateTime, true);
                }
                else {
                    // In this case we have an eventEndDate but it is not relative
                }
            }
            else {
                fromDateTime = Types_1.RelativeDate.from(relativeFromDate, relativeTo);
            }
        }
        granularity = "instant";
    }
    else if (nowFrom) {
        fromDateTime = context.now;
        granularity = "instant";
    }
    else {
        fromDateTime = luxon_1.DateTime.fromISO(edtfFrom);
        granularity = "instant";
    }
    if (!fromDateTime || !fromDateTime?.isValid) {
        fromDateTime = context.now;
        granularity = "instant";
    }
    if (!endDateTime) {
        if (relativeToDate) {
            // Dependent on other event
            canCacheRange = false;
            const relativeToEventId = eventStartLineRegexMatch[regex_1.to_edtfRelativeEventIdMatchIndex];
            let relativeTo = relativeToEventId &&
                context.ids[relativeToEventId] &&
                (0, Types_1.toDateRange)(context.ids[relativeToEventId].dateRangeIso).toDateTime;
            if (!relativeTo) {
                // We do not have an event to refer to by id, use the start of this event
                relativeTo = fromDateTime;
            }
            endDateTime = Types_1.RelativeDate.from(relativeToDate, relativeTo);
        }
        else if (nowTo) {
            endDateTime = context.now;
            granularity = "instant";
        }
        else if (edtfTo) {
            endDateTime = luxon_1.DateTime.fromISO((0, utils_1.roundDateUp)({
                dateTimeIso: edtfTo,
                granularity: edtfToHasDay
                    ? "day"
                    : edtfToHasMonth
                        ? "month"
                        : "year",
            }, cache));
        }
    }
    if (!endDateTime || !endDateTime.isValid) {
        endDateTime = luxon_1.DateTime.fromISO((0, utils_1.roundDateUp)({
            dateTimeIso: fromDateTime.toISO(),
            granularity,
        }, cache));
    }
    const recurrence = (0, checkRecurrence_1.checkEdtfRecurrence)(eventStartLineRegexMatch, lengthAtIndex, i);
    if (recurrence) {
        context.ranges.push(recurrence.range);
        context.ranges.push(colonRange(Types_1.RangeType.Recurrence));
    }
    else {
        context.ranges.push(colonRange(Types_1.RangeType.DateRange));
    }
    const dateRange = new Types_1.DateRangePart(fromDateTime, endDateTime, datePart, dateRangeInText, eventStartLineRegexMatch[regex_1.edtfEventTextMatchIndex], recurrence);
    if (canCacheRange && cache) {
        cache.ranges.set(datePart, {
            fromDateTimeIso: fromDateTime.toISO(),
            toDateTimeIso: endDateTime.toISO(),
        });
    }
    return dateRange;
}
exports.getDateRangeFromEDTFRegexMatch = getDateRangeFromEDTFRegexMatch;
