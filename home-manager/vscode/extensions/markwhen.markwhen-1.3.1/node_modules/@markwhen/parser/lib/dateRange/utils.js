"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.roundDateUp = exports.parseSlashDate = exports.getPriorEventFromDateTime = exports.getPriorEventToDateTime = exports.getPriorEvent = exports.parseGroupFromStartTag = exports.parseAsCasualDayAbbrMonth = exports.parseAsCasualDayFullMonth = exports.fromCasualDateTo = exports.fromCasualDateFrom = exports.getTimeFromCasualMonthTo = exports.getTimeFromCasualMonthFrom = exports.getTimeFromSlashDateTo = exports.getTimeFromSlashDateFrom = exports.getTimeFromRegExpMatch = void 0;
const luxon_1 = require("luxon");
const regex_1 = require("../regex");
const Node_1 = require("../Node");
const Types_1 = require("../Types");
function getTimeFromRegExpMatch(eventStartMatches, meridiemHourIndex, meridiemMinuteIndex, meridiemIndex, time24HourHourIndex, time24HourMinuteIndex) {
    const timeMeridiemHour = eventStartMatches[meridiemHourIndex];
    const timeMeridiemMinute = eventStartMatches[meridiemMinuteIndex] || ":00";
    const timeMeridiem = eventStartMatches[meridiemIndex] || "am";
    if (timeMeridiemHour) {
        return {
            dateTimeIso: luxon_1.DateTime.fromFormat(`${timeMeridiemHour}${timeMeridiemMinute}${timeMeridiem}`, "h:mma").toISO(),
            granularity: timeMeridiemMinute === ":00" ? "hour" : "minute",
        };
    }
    const time24HourHour = eventStartMatches[time24HourHourIndex];
    const time24HourMinute = eventStartMatches[time24HourMinuteIndex];
    return {
        dateTimeIso: luxon_1.DateTime.fromFormat(`${time24HourHour}${time24HourMinute}`, `${time24HourHour.length === 2 && time24HourHour[0] === "0" ? "HH" : "H"}:mm`).toISO(),
        granularity: time24HourMinute === ":00" ? "hour" : "minute",
    };
}
exports.getTimeFromRegExpMatch = getTimeFromRegExpMatch;
function getTimeFromSlashDateFrom(eventStartMatches) {
    const meridiemHourIndex = regex_1.from_slashDateTimeMeridiemHourMatchIndex;
    const meridiemMinuteIndex = regex_1.from_slashDateTimeMeridiemMinuteMatchIndex;
    const meridiemIndex = regex_1.from_slashDateTimeMeridiemMeridiemMatchIndex;
    const time24HourHourIndex = regex_1.from_slashDateTime24HourHourMatchIndex;
    const time24HourMinuteIndex = regex_1.from_slashDateTime24HourMinuteMatchIndex;
    return getTimeFromRegExpMatch(eventStartMatches, meridiemHourIndex, meridiemMinuteIndex, meridiemIndex, time24HourHourIndex, time24HourMinuteIndex);
}
exports.getTimeFromSlashDateFrom = getTimeFromSlashDateFrom;
function getTimeFromSlashDateTo(eventStartMatches) {
    const meridiemHourIndex = regex_1.to_slashDateTimeMeridiemHourMatchIndex;
    const meridiemMinuteIndex = regex_1.to_slashDateTimeMeridiemMinuteMatchIndex;
    const meridiemIndex = regex_1.to_slashDateTimeMeridiemMeridiemMatchIndex;
    const time24HourHourIndex = regex_1.to_slashDateTime24HourHourMatchIndex;
    const time24HourMinuteIndex = regex_1.to_slashDateTime24HourMinuteMatchIndex;
    return getTimeFromRegExpMatch(eventStartMatches, meridiemHourIndex, meridiemMinuteIndex, meridiemIndex, time24HourHourIndex, time24HourMinuteIndex);
}
exports.getTimeFromSlashDateTo = getTimeFromSlashDateTo;
function getTimeFromCasualMonthFrom(eventStartMatches) {
    const meridiemHourIndex = regex_1.from_casualMonthTimeMeridiemHourMatchIndex;
    const meridiemMinuteIndex = regex_1.from_casualMonthTimeMeridiemMinuteMatchIndex;
    const meridiemIndex = regex_1.from_casualMonthTimeMeridiemMeridiemMatchIndex;
    const time24HourHourIndex = regex_1.from_casualMonthTime24HourHourMatchIndex;
    const time24HourMinuteIndex = regex_1.from_casualMonthTime24HourMinuteMatchIndex;
    return getTimeFromRegExpMatch(eventStartMatches, meridiemHourIndex, meridiemMinuteIndex, meridiemIndex, time24HourHourIndex, time24HourMinuteIndex);
}
exports.getTimeFromCasualMonthFrom = getTimeFromCasualMonthFrom;
function getTimeFromCasualMonthTo(eventStartMatches) {
    const meridiemHourIndex = regex_1.to_casualMonthTimeMeridiemHourMatchIndex;
    const meridiemMinuteIndex = regex_1.to_casualMonthTimeMeridiemMinuteMatchIndex;
    const meridiemIndex = regex_1.to_casualMonthTimeMeridiemMeridiemMatchIndex;
    const time24HourHourIndex = regex_1.to_casualMonthTime24HourHourMatchIndex;
    const time24HourMinuteIndex = regex_1.to_casualMonthTime24HourMinuteMatchIndex;
    return getTimeFromRegExpMatch(eventStartMatches, meridiemHourIndex, meridiemMinuteIndex, meridiemIndex, time24HourHourIndex, time24HourMinuteIndex);
}
exports.getTimeFromCasualMonthTo = getTimeFromCasualMonthTo;
function fromCasualDateFrom(eventStartMatches) {
    let month = eventStartMatches[regex_1.from_monthFirstCasualMonthMonthFullMatchIndex];
    let day = eventStartMatches[regex_1.from_monthFirstCasualMonthDayMatchIndex];
    let year = eventStartMatches[regex_1.from_casualMonthAndDayYearMatchIndex] ||
        `${luxon_1.DateTime.now().year}`;
    let timeMatch = eventStartMatches[regex_1.from_casualMonthTimeMatchIndex] &&
        getTimeFromCasualMonthFrom(eventStartMatches);
    let date = month &&
        day &&
        parseAsCasualDayFullMonth(`${year} ${month} ${parseInt(day)}`);
    month = eventStartMatches[regex_1.from_monthFirstCasualMonthMonthAbbrMatchIndex];
    date =
        date ||
            (month &&
                day &&
                parseAsCasualDayAbbrMonth(`${year} ${month} ${parseInt(day)}`));
    day = eventStartMatches[regex_1.from_dayFirstCasualMonthDayMatchIndex];
    month = eventStartMatches[regex_1.from_dayFirstCasualMonthMonthFullMatchIndex];
    date =
        date ||
            (month &&
                day &&
                parseAsCasualDayFullMonth(`${year} ${month} ${parseInt(day)}`));
    month = eventStartMatches[regex_1.from_dayFirstCasualMonthMonthAbbrMatchIndex];
    date =
        date ||
            (month &&
                day &&
                parseAsCasualDayAbbrMonth(`${year} ${month} ${parseInt(day)}`));
    if (date) {
        if (timeMatch) {
            const dt = luxon_1.DateTime.fromISO(date.dateTimeIso);
            const timeMatchIso = luxon_1.DateTime.fromISO(timeMatch.dateTimeIso);
            date.dateTimeIso = dt
                .set({
                hour: timeMatchIso.hour,
                minute: timeMatchIso.minute,
            })
                .toISO();
            date.granularity = timeMatch.granularity;
        }
        return date;
    }
    year =
        eventStartMatches[regex_1.from_casualMonthYearMatchIndex] ||
            `${luxon_1.DateTime.now().year}`;
    month = eventStartMatches[regex_1.from_casualMonthMonthFullMatchIndex];
    if (month) {
        return {
            dateTimeIso: luxon_1.DateTime.fromFormat(`${year} ${month}`, "y MMMM").toISO(),
            granularity: "month",
        };
    }
    month = eventStartMatches[regex_1.from_casualMonthMonthAbbrMatchIndex];
    if (month) {
        return {
            dateTimeIso: luxon_1.DateTime.fromFormat(`${year} ${month}`, "y MMM").toISO(),
            granularity: "month",
        };
    }
}
exports.fromCasualDateFrom = fromCasualDateFrom;
function fromCasualDateTo(eventStartMatches) {
    let month = eventStartMatches[regex_1.to_monthFirstCasualMonthMonthFullMatchIndex];
    let day = eventStartMatches[regex_1.to_monthFirstCasualMonthDayMatchIndex];
    let year = eventStartMatches[regex_1.to_casualMonthAndDayYearMatchIndex] ||
        `${luxon_1.DateTime.now().year}`;
    let timeMatch = eventStartMatches[regex_1.to_casualMonthTimeMatchIndex] &&
        getTimeFromCasualMonthTo(eventStartMatches);
    let date = month &&
        day &&
        parseAsCasualDayFullMonth(`${year} ${month} ${parseInt(day)}`);
    month = eventStartMatches[regex_1.to_monthFirstCasualMonthMonthAbbrMatchIndex];
    date =
        date ||
            (month &&
                day &&
                parseAsCasualDayAbbrMonth(`${year} ${month} ${parseInt(day)}`));
    day = eventStartMatches[regex_1.to_dayFirstCasualMonthDayMatchIndex];
    month = eventStartMatches[regex_1.to_dayFirstCasualMonthMonthFullMatchIndex];
    date =
        date ||
            (month &&
                day &&
                parseAsCasualDayFullMonth(`${year} ${month} ${parseInt(day)}`));
    month = eventStartMatches[regex_1.to_dayFirstCasualMonthMonthAbbrMatchIndex];
    date =
        date ||
            (month &&
                day &&
                parseAsCasualDayAbbrMonth(`${year} ${month} ${parseInt(day)}`));
    if (date) {
        if (timeMatch) {
            if (timeMatch) {
                const dt = luxon_1.DateTime.fromISO(date.dateTimeIso);
                const timeMatchIso = luxon_1.DateTime.fromISO(timeMatch.dateTimeIso);
                date.dateTimeIso = dt
                    .set({
                    hour: timeMatchIso.hour,
                    minute: timeMatchIso.minute,
                })
                    .toISO();
                date.granularity = timeMatch.granularity;
            }
        }
        return date;
    }
    year =
        eventStartMatches[regex_1.to_casualMonthYearMatchIndex] || `${luxon_1.DateTime.now().year}`;
    month = eventStartMatches[regex_1.to_casualMonthMonthFullMatchIndex];
    if (month) {
        return {
            dateTimeIso: luxon_1.DateTime.fromFormat(`${year} ${month}`, "y MMMM").toISO(),
            granularity: "month",
        };
    }
    month = eventStartMatches[regex_1.to_casualMonthMonthAbbrMatchIndex];
    if (month) {
        return {
            dateTimeIso: luxon_1.DateTime.fromFormat(`${year} ${month}`, "y MMM").toISO(),
            granularity: "month",
        };
    }
}
exports.fromCasualDateTo = fromCasualDateTo;
function parseAsCasualDayFullMonth(s) {
    return {
        dateTimeIso: luxon_1.DateTime.fromFormat(s, "y MMMM d").toISO(),
        granularity: "day",
    };
}
exports.parseAsCasualDayFullMonth = parseAsCasualDayFullMonth;
function parseAsCasualDayAbbrMonth(s) {
    return {
        dateTimeIso: luxon_1.DateTime.fromFormat(s, "y MMM d").toISO(),
        granularity: "day",
    };
}
exports.parseAsCasualDayAbbrMonth = parseAsCasualDayAbbrMonth;
function parseGroupFromStartTag(s, regexMatch, range) {
    const group = new Node_1.Node([]);
    group.tags = [];
    group.style = "group";
    group.rangeInText = range;
    s = s
        .replace(regex_1.GROUP_START_REGEX, (match, startToken, groupOrSection) => {
        // Start expanded if this start tag is not indented
        group.startExpanded = !startToken.length;
        group.style = groupOrSection;
        return "";
    })
        .replace(regex_1.TAG_REGEX, (match, tag) => {
        if (!group.tags.includes(tag)) {
            group.tags.push(tag);
        }
        return "";
    });
    group.title = s.trim();
    return group;
}
exports.parseGroupFromStartTag = parseGroupFromStartTag;
function getPriorEvent(context) {
    return context.tail?.value;
}
exports.getPriorEvent = getPriorEvent;
function getPriorEventToDateTime(context) {
    const priorEvent = getPriorEvent(context);
    if (!priorEvent) {
        return;
    }
    return (0, Types_1.toDateRange)(priorEvent.dateRangeIso).toDateTime;
}
exports.getPriorEventToDateTime = getPriorEventToDateTime;
function getPriorEventFromDateTime(context) {
    const priorEvent = getPriorEvent(context);
    if (!priorEvent) {
        return;
    }
    return (0, Types_1.toDateRange)(priorEvent.dateRangeIso).fromDateTime;
}
exports.getPriorEventFromDateTime = getPriorEventFromDateTime;
function parseSlashDate(s, fullFormat, cache) {
    const cacheKey = JSON.stringify({ s, fullFormat });
    const cached = cache?.slashDate.get(cacheKey);
    if (cached) {
        return cached;
    }
    const cacheAndReturn = (gdt) => {
        cache?.slashDate.set(cacheKey, gdt);
        return gdt;
    };
    let dateTime = luxon_1.DateTime.fromFormat(s, fullFormat);
    if (dateTime.isValid) {
        return cacheAndReturn({
            dateTimeIso: dateTime.toISO(),
            granularity: "day",
        });
    }
    dateTime = luxon_1.DateTime.fromFormat(s, Types_1.DATE_TIME_FORMAT_MONTH_YEAR);
    if (dateTime.isValid) {
        return cacheAndReturn({
            dateTimeIso: dateTime.toISO(),
            granularity: "month",
        });
    }
    dateTime = luxon_1.DateTime.fromFormat(s, Types_1.DATE_TIME_FORMAT_YEAR);
    if (dateTime.isValid) {
        return cacheAndReturn({
            dateTimeIso: dateTime.toISO(),
            granularity: "year",
        });
    }
}
exports.parseSlashDate = parseSlashDate;
function roundDateUp(granularDateTime, cache) {
    const cacheKey = JSON.stringify(granularDateTime);
    const cached = cache?.roundDateUp.get(cacheKey);
    if (cached) {
        return cached;
    }
    const cacheAndReturn = (s) => {
        cache?.roundDateUp.set(cacheKey, s);
        return s;
    };
    const dt = luxon_1.DateTime.fromISO(granularDateTime.dateTimeIso);
    if (!dt.isValid) {
        return cacheAndReturn(granularDateTime.dateTimeIso);
    }
    if (["instant", "hour", "minute", "second"].includes(granularDateTime.granularity)) {
        return cacheAndReturn(granularDateTime.dateTimeIso);
    }
    return cacheAndReturn(dt
        .plus({
        [granularDateTime.granularity]: 1,
    })
        .toISO());
}
exports.roundDateUp = roundDateUp;
