"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkRecurrence = exports.checkEdtfRecurrence = exports.recurrenceDurationUnits = void 0;
const regex_1 = require("../regex");
const Types_1 = require("../Types");
exports.recurrenceDurationUnits = [
    "years",
    "months",
    "weeks",
    "weekdays",
    "days",
    "hours",
    "minutes",
    "seconds",
    "milliseconds",
];
const checkEdtfRecurrence = (eventStartLineRegexMatch, lengthAtIndex, i) => {
    const recurrenceMatch = eventStartLineRegexMatch[regex_1.recurrence_edtfRecurrenceMatchIndex];
    if (!recurrenceMatch) {
        return;
    }
    const indexInString = eventStartLineRegexMatch[0].indexOf(recurrenceMatch);
    const range = {
        type: Types_1.RangeType.Recurrence,
        from: lengthAtIndex[i] + indexInString,
        to: lengthAtIndex[i] + indexInString + recurrenceMatch.length,
        lineFrom: { line: i, index: indexInString },
        lineTo: { line: i, index: indexInString + recurrenceMatch.length },
        content: recurrenceMatch
    };
    let recurrenceCount;
    const recurrenceAmountString = eventStartLineRegexMatch[regex_1.recurrence_edtfRecurrenceAmountMatchIndex];
    if (recurrenceAmountString) {
        if (recurrenceAmountString.trim().toLowerCase() === "other") {
            recurrenceCount = 2;
        }
        else {
            recurrenceCount = parseInt(recurrenceAmountString.trim());
        }
    }
    else {
        recurrenceCount = 1;
    }
    const recurrenceUnitIndex = [
        regex_1.recurrence_edtfRecurrenceAmountYearsUnitMatchIndex,
        regex_1.recurrence_edtfRecurrenceAmountMonthsUnitMatchIndex,
        regex_1.recurrence_edtfRecurrenceAmountWeeksUnitMatchIndex,
        regex_1.recurrence_edtfRecurrenceAmountWeekDayMatchIndex,
        regex_1.recurrence_edtfRecurrenceAmountDaysUnitMatchIndex,
        regex_1.recurrence_edtfRecurrenceAmountHoursUnitMatchIndex,
        regex_1.recurrence_edtfRecurrenceAmountMinutesUnitMatchIndex,
        regex_1.recurrence_edtfRecurrenceAmountSecondsUnitMatchIndex,
        regex_1.recurrence_edtfRecurrenceAmountMillisecondsUnitMatchIndex,
    ].findIndex((regex) => !!eventStartLineRegexMatch[regex]);
    const unit = exports.recurrenceDurationUnits[recurrenceUnitIndex];
    const every = {
        [unit]: recurrenceCount,
    };
    if (eventStartLineRegexMatch[regex_1.recurrence_edtfRepetitionsMatchIndex]) {
        if (eventStartLineRegexMatch[regex_1.recurrence_edtfRepetitionsForAmountMatchIndex]) {
            const repetitionCount = parseInt(eventStartLineRegexMatch[regex_1.recurrence_edtfRepetitionsForAmountAmountMatchIndex].trim());
            const units = [...exports.recurrenceDurationUnits, "times"];
            const repeitionUnitIndex = [
                regex_1.recurrence_edtfRepetitionsForAmountYearsUnitMatchIndex,
                regex_1.recurrence_edtfRepetitionsForAmountMonthsUnitMatchIndex,
                regex_1.recurrence_edtfRepetitionsForAmountWeeksUnitMatchIndex,
                regex_1.recurrence_edtfRepetitionsForAmountWeekDayMatchIndex,
                regex_1.recurrence_edtfRepetitionsForAmountDaysUnitMatchIndex,
                regex_1.recurrence_edtfRepetitionsForAmountHoursUnitMatchIndex,
                regex_1.recurrence_edtfRepetitionsForAmountMinutesUnitMatchIndex,
                regex_1.recurrence_edtfRepetitionsForAmountSecondsUnitMatchIndex,
                regex_1.recurrence_edtfRepetitionsForAmountMillisecondsUnitMatchIndex,
                regex_1.recurrence_edtfRepetitionsForAmountTimesMatchIndex,
            ].findIndex((regex) => eventStartLineRegexMatch[regex]);
            const repetitionUnit = units[repeitionUnitIndex];
            return {
                recurrence: {
                    every,
                    for: {
                        [repetitionUnit]: repetitionCount,
                    },
                },
                range,
            };
        }
        else {
            const repetitionCount = parseInt(eventStartLineRegexMatch[regex_1.recurrence_edtfRecurrenceAmountXNotationAmountMatchIndex].trim());
            return {
                recurrence: {
                    every,
                    for: {
                        times: repetitionCount,
                    },
                },
                range,
            };
        }
    }
    return { recurrence: { every }, range };
};
exports.checkEdtfRecurrence = checkEdtfRecurrence;
const checkRecurrence = (eventStartLineRegexMatch, lengthAtIndex, i) => {
    const recurrenceMatch = eventStartLineRegexMatch[regex_1.recurrence_recurrenceMatchIndex];
    if (!recurrenceMatch) {
        return;
    }
    const indexInString = eventStartLineRegexMatch[0].indexOf(recurrenceMatch);
    const range = {
        type: Types_1.RangeType.Recurrence,
        from: lengthAtIndex[i] + indexInString,
        to: lengthAtIndex[i] + indexInString + recurrenceMatch.length,
        lineFrom: { line: i, index: indexInString },
        lineTo: { line: i, index: indexInString + recurrenceMatch.length },
        content: recurrenceMatch
    };
    let recurrenceCount;
    if (eventStartLineRegexMatch[regex_1.recurrence_recurrenceAmountMatchIndex]) {
        const recurrenceAmountString = eventStartLineRegexMatch[regex_1.recurrence_recurrenceAmountMatchIndex].trim();
        if (recurrenceAmountString.toLowerCase() === "other") {
            recurrenceCount = 2;
        }
        else {
            recurrenceCount = parseInt(recurrenceAmountString);
        }
    }
    else {
        recurrenceCount = 1;
    }
    const units = [
        "years",
        "months",
        "weeks",
        "weekdays",
        "days",
        "hours",
        "minutes",
        "seconds",
        "milliseconds",
    ];
    const recurrenceUnitIndex = [
        regex_1.recurrence_recurrenceAmountYearsUnitMatchIndex,
        regex_1.recurrence_recurrenceAmountMonthsUnitMatchIndex,
        regex_1.recurrence_recurrenceAmountWeeksUnitMatchIndex,
        regex_1.recurrence_recurrenceAmountWeekDayMatchIndex,
        regex_1.recurrence_recurrenceAmountDaysUnitMatchIndex,
        regex_1.recurrence_recurrenceAmountHoursUnitMatchIndex,
        regex_1.recurrence_recurrenceAmountMinutesUnitMatchIndex,
        regex_1.recurrence_recurrenceAmountSecondsUnitMatchIndex,
        regex_1.recurrence_recurrenceAmountMillisecondsUnitMatchIndex,
    ].findIndex((regex) => !!eventStartLineRegexMatch[regex]);
    const unit = units[recurrenceUnitIndex];
    const every = {
        [unit]: recurrenceCount,
    };
    if (eventStartLineRegexMatch[regex_1.recurrence_repetitionsMatchIndex]) {
        if (eventStartLineRegexMatch[regex_1.recurrence_repetitionsForAmountMatchIndex]) {
            const repetitionCount = parseInt(eventStartLineRegexMatch[regex_1.recurrence_repetitionsForAmountAmountMatchIndex].trim());
            const units = [
                "years",
                "months",
                "weeks",
                "weekdays",
                "days",
                "hours",
                "minutes",
                "seconds",
                "milliseconds",
                "times",
            ];
            const repeitionUnitIndex = [
                regex_1.recurrence_repetitionsForAmountYearsUnitMatchIndex,
                regex_1.recurrence_repetitionsForAmountMonthsUnitMatchIndex,
                regex_1.recurrence_repetitionsForAmountWeeksUnitMatchIndex,
                regex_1.recurrence_repetitionsForAmountWeekDayMatchIndex,
                regex_1.recurrence_repetitionsForAmountDaysUnitMatchIndex,
                regex_1.recurrence_repetitionsForAmountHoursUnitMatchIndex,
                regex_1.recurrence_repetitionsForAmountMinutesUnitMatchIndex,
                regex_1.recurrence_repetitionsForAmountSecondsUnitMatchIndex,
                regex_1.recurrence_repetitionsForAmountMillisecondsUnitMatchIndex,
                regex_1.recurrence_repetitionsForAmountTimesMatchIndex,
            ].findIndex((regex) => eventStartLineRegexMatch[regex]);
            const repetitionUnit = units[repeitionUnitIndex];
            return {
                recurrence: {
                    every,
                    for: {
                        [repetitionUnit]: repetitionCount,
                    },
                },
                range,
            };
        }
        else {
            const repetitionCount = parseInt(eventStartLineRegexMatch[regex_1.recurrence_recurrenceAmountXNotationAmountMatchIndex].trim());
            return {
                recurrence: {
                    every,
                    for: {
                        times: repetitionCount,
                    },
                },
                range,
            };
        }
    }
    return { recurrence: { every }, range };
};
exports.checkRecurrence = checkRecurrence;
