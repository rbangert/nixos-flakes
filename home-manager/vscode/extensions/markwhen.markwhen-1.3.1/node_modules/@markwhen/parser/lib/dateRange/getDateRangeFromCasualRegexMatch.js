"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDateRangeFromCasualRegexMatch = void 0;
const luxon_1 = require("luxon");
const regex_1 = require("../regex");
const Types_1 = require("../Types");
const utils_1 = require("./utils");
const checkRecurrence_1 = require("./checkRecurrence");
function getDateRangeFromCasualRegexMatch(line, i, lengthAtIndex, context, cache) {
    const eventStartLineRegexMatch = line.match(regex_1.EVENT_START_REGEX);
    if (!eventStartLineRegexMatch) {
        return;
    }
    // What the regex matched as the date range part
    const datePart = eventStartLineRegexMatch[regex_1.datePartMatchIndex];
    const eventStartDate = eventStartLineRegexMatch[regex_1.from_matchIndex];
    const eventEndDate = eventStartLineRegexMatch[regex_1.to_matchIndex];
    const relativeFromDate = eventStartLineRegexMatch[regex_1.from_relativeMatchIndex];
    const relativeFromBeforeOrAfter = eventStartLineRegexMatch[regex_1.from_beforeOrAfterMatchIndex];
    const fromBeforeOrAfter = ["before", "by"].includes(relativeFromBeforeOrAfter || "")
        ? "before"
        : "after";
    const relativeToDate = eventStartLineRegexMatch[regex_1.to_relativeMatchIndex];
    const relativeToBeforeOrAfter = eventStartLineRegexMatch[regex_1.to_beforeOrAfterMatchIndex];
    const toBeforeOrAfter = ["before", "by"].includes(relativeToBeforeOrAfter || "")
        ? "before"
        : "after";
    const fromCasual = (0, utils_1.fromCasualDateFrom)(eventStartLineRegexMatch);
    const toCasual = (0, utils_1.fromCasualDateTo)(eventStartLineRegexMatch);
    const slashDateFrom = eventStartLineRegexMatch[regex_1.from_slashDateFullMatchIndex];
    const slashDateTo = eventStartLineRegexMatch[regex_1.to_slashDateFullMatchIndex];
    const timeOnlyFrom = eventStartLineRegexMatch[regex_1.from_timeOnlyMatchIndex];
    const timeOnlyTo = eventStartLineRegexMatch[regex_1.to_timeOnlyMatchIndex];
    const nowFrom = eventStartLineRegexMatch[regex_1.from_nowMatchIndex];
    const nowTo = eventStartLineRegexMatch[regex_1.to_nowMatchIndex];
    let fromDateTime;
    let endDateTime;
    let granularity = "instant";
    let canCacheRange = true;
    const indexOfDateRange = line.indexOf(datePart);
    const dateRangeInText = {
        type: Types_1.RangeType.DateRange,
        from: lengthAtIndex[i] + indexOfDateRange,
        to: lengthAtIndex[i] + indexOfDateRange + datePart.length,
        lineFrom: {
            line: i,
            index: indexOfDateRange,
        },
        lineTo: {
            line: i,
            index: indexOfDateRange + datePart.length,
        },
    };
    context.ranges.push(dateRangeInText);
    const colonIndex = line.indexOf(":", indexOfDateRange + datePart.length);
    const colonRange = (rangeType) => ({
        type: rangeType,
        from: lengthAtIndex[i] + colonIndex,
        to: lengthAtIndex[i] + colonIndex + 1,
        lineFrom: {
            line: i,
            index: colonIndex,
        },
        lineTo: {
            line: i,
            index: colonIndex + 1,
        },
    });
    const cached = cache?.ranges.get(datePart);
    if (cached) {
        const recurrence = (0, checkRecurrence_1.checkRecurrence)(eventStartLineRegexMatch, lengthAtIndex, i);
        if (recurrence) {
            context.ranges.push(recurrence.range);
            context.ranges.push(colonRange(Types_1.RangeType.Recurrence));
        }
        else {
            context.ranges.push(colonRange(Types_1.RangeType.DateRange));
        }
        const dateRange = new Types_1.DateRangePart(luxon_1.DateTime.fromISO(cached.fromDateTimeIso), luxon_1.DateTime.fromISO(cached.toDateTimeIso), datePart, dateRangeInText, eventStartLineRegexMatch[regex_1.eventTextMatchIndex], recurrence);
        return dateRange;
    }
    if (relativeFromDate) {
        // Dependent on other events
        canCacheRange = false;
        const relativeToEventId = eventStartLineRegexMatch[regex_1.from_relativeEventIdMatchIndex];
        let relativeTo = relativeToEventId &&
            (fromBeforeOrAfter === "after"
                ? context.ids[relativeToEventId]
                    ? (0, Types_1.toDateRange)(context.ids[relativeToEventId].dateRangeIso).toDateTime
                    : undefined
                : context.ids[relativeToEventId]
                    ? (0, Types_1.toDateRange)(context.ids[relativeToEventId].dateRangeIso).fromDateTime
                    : undefined);
        if (!relativeTo) {
            const priorEvent = (0, utils_1.getPriorEvent)(context);
            if (!priorEvent) {
                relativeTo = context.now;
            }
            else {
                relativeTo =
                    fromBeforeOrAfter === "after"
                        ? (0, Types_1.toDateRange)(priorEvent.dateRangeIso).toDateTime
                        : (0, Types_1.toDateRange)(priorEvent.dateRangeIso).fromDateTime;
            }
        }
        if (!relativeToDate && !eventEndDate) {
            if (fromBeforeOrAfter === "before") {
                // In the case of this being a 'before' relative date, the
                // end date is relativeTo and the start date is `amount` before it.
                endDateTime = relativeTo;
                fromDateTime = Types_1.RelativeDate.from(relativeFromDate, relativeTo, true);
            }
            else {
                fromDateTime = relativeTo;
                endDateTime = Types_1.RelativeDate.from(relativeFromDate, relativeTo);
            }
        }
        else {
            if (fromBeforeOrAfter === "before") {
                if (relativeToDate) {
                    // in this case we're actually determining the end dateTime, with its duration,
                    // or start time, to be figured out from the eventEndDate
                    endDateTime = Types_1.RelativeDate.from(relativeFromDate, relativeTo, true);
                    fromDateTime = Types_1.RelativeDate.from(relativeToDate, endDateTime, true);
                }
                else {
                    // In this case we have an eventEndDate but it is not relative
                }
            }
            else {
                fromDateTime = Types_1.RelativeDate.from(relativeFromDate, relativeTo);
            }
        }
        granularity = "instant";
    }
    else if (fromCasual) {
        fromDateTime = luxon_1.DateTime.fromISO(fromCasual.dateTimeIso);
        granularity = fromCasual.granularity;
    }
    else if (slashDateFrom) {
        const timeComponent = eventStartLineRegexMatch[regex_1.from_slashDateTimeMatchIndex];
        let slashPart = slashDateFrom;
        if (timeComponent) {
            slashPart = slashPart
                .substring(0, slashPart.indexOf(timeComponent))
                .trim()
                .replace(/,/g, "");
        }
        const parsed = (0, utils_1.parseSlashDate)(slashPart, context.dateFormat, cache);
        if (parsed) {
            if (timeComponent) {
                const timePart = (0, utils_1.getTimeFromSlashDateFrom)(eventStartLineRegexMatch);
                const timePartDateTime = luxon_1.DateTime.fromISO(timePart.dateTimeIso);
                fromDateTime = luxon_1.DateTime.fromISO(parsed.dateTimeIso).set({
                    hour: timePartDateTime.hour,
                    minute: timePartDateTime.minute,
                });
                granularity = timePart.granularity;
            }
            else {
                fromDateTime = luxon_1.DateTime.fromISO(parsed.dateTimeIso);
                granularity = parsed.granularity;
            }
            // Something non-ISO has come up, assume they want that
            context.preferredInterpolationFormat = context.dateFormat;
        }
        else {
            console.error("Was supposed to have slash date but couldn't parse it.");
        }
    }
    else if (timeOnlyFrom) {
        // Dependent on previous event
        canCacheRange = false;
        const timeFrom = (0, utils_1.getTimeFromRegExpMatch)(eventStartLineRegexMatch, regex_1.from_timeOnlyMeridiemHourMatchIndex, regex_1.from_timeOnlyMeridiemMinuteMatchIndex, regex_1.from_timeOnlyMeridiemMeridiemMatchIndex, regex_1.from_timeOnly24HourHourMatchIndex, regex_1.from_timeOnly24HourMinuteMatchIndex);
        const priorEventDate = (0, utils_1.getPriorEventToDateTime)(context) || luxon_1.DateTime.now();
        const timeFromIso = luxon_1.DateTime.fromISO(timeFrom.dateTimeIso);
        let priorEventWithParsedTime = priorEventDate.set({
            hour: timeFromIso.hour,
            minute: timeFromIso.minute,
        });
        if (priorEventWithParsedTime < priorEventDate) {
            priorEventWithParsedTime = priorEventWithParsedTime.plus({ days: 1 });
            fromDateTime = priorEventWithParsedTime;
            granularity = timeFrom.granularity;
        }
        else {
            fromDateTime = priorEventWithParsedTime;
            granularity = timeFrom.granularity;
        }
    }
    else if (nowFrom) {
        fromDateTime = context.now;
        granularity = "instant";
    }
    else {
        fromDateTime = luxon_1.DateTime.fromISO(eventStartDate);
        granularity = "instant";
    }
    if (!fromDateTime || !fromDateTime.isValid) {
        fromDateTime = context.now;
        granularity = "instant";
    }
    if (!endDateTime) {
        if (relativeToDate) {
            canCacheRange = false;
            const relativeToEventId = eventStartLineRegexMatch[regex_1.to_relativeEventIdMatchIndex];
            let relativeTo = relativeToEventId &&
                context.ids[relativeToEventId] &&
                (0, Types_1.toDateRange)(context.ids[relativeToEventId].dateRangeIso).toDateTime;
            if (!relativeTo) {
                // We do not have an event to refer to by id, use the start of this event
                relativeTo = fromDateTime;
            }
            endDateTime = Types_1.RelativeDate.from(eventEndDate, relativeTo);
        }
        else if (toCasual) {
            endDateTime = luxon_1.DateTime.fromISO((0, utils_1.roundDateUp)(toCasual, cache));
        }
        else if (slashDateTo) {
            const timeComponent = eventStartLineRegexMatch[regex_1.to_slashDateTimeMatchIndex];
            let slashPart = slashDateTo;
            if (timeComponent) {
                slashPart = slashPart
                    .substring(0, slashPart.indexOf(timeComponent))
                    .trim()
                    .replace(/,/g, "");
            }
            const parsed = (0, utils_1.parseSlashDate)(slashPart, context.dateFormat, cache);
            if (parsed) {
                if (timeComponent) {
                    const parsedFromIso = luxon_1.DateTime.fromISO(parsed.dateTimeIso);
                    const timePart = (0, utils_1.getTimeFromSlashDateTo)(eventStartLineRegexMatch);
                    const timePartFromIso = luxon_1.DateTime.fromISO(timePart.dateTimeIso);
                    endDateTime = parsedFromIso.set({
                        hour: timePartFromIso.hour,
                        minute: timePartFromIso.minute,
                    });
                    endDateTime = luxon_1.DateTime.fromISO((0, utils_1.roundDateUp)({
                        dateTimeIso: endDateTime.toISO(),
                        granularity: timePart.granularity,
                    }, cache));
                }
                else {
                    endDateTime = luxon_1.DateTime.fromISO((0, utils_1.roundDateUp)(parsed, cache));
                }
                // Something non-ISO has come up, assume they want that
                context.preferredInterpolationFormat = context.dateFormat;
            }
            else {
                console.error("Was supposed to have slash date but couldn't parse it.");
            }
        }
        else if (timeOnlyTo) {
            const timeTo = (0, utils_1.getTimeFromRegExpMatch)(eventStartLineRegexMatch, regex_1.to_timeOnlyMeridiemHourMatchIndex, regex_1.to_timeOnlyMeridiemMinuteMatchIndex, regex_1.to_timeOnlyMeridiemMeridiemMatchIndex, regex_1.to_timeOnly24HourHourMatchIndex, regex_1.to_timeOnly24HourMinuteMatchIndex);
            const timeToIso = luxon_1.DateTime.fromISO(timeTo.dateTimeIso);
            let eventStartWithTimeTo = fromDateTime.set({
                hour: timeToIso.hour,
                minute: timeToIso.minute,
            });
            if (eventStartWithTimeTo < fromDateTime) {
                eventStartWithTimeTo = eventStartWithTimeTo.plus({ days: 1 });
            }
            endDateTime = eventStartWithTimeTo;
            granularity = timeTo.granularity;
        }
        else if (nowTo) {
            endDateTime = luxon_1.DateTime.now();
            granularity = "instant";
        }
        else {
            endDateTime = luxon_1.DateTime.fromISO((0, utils_1.roundDateUp)({
                dateTimeIso: eventEndDate,
                granularity: "instant",
            }, cache));
        }
    }
    if (!endDateTime || !endDateTime.isValid) {
        endDateTime = luxon_1.DateTime.fromISO((0, utils_1.roundDateUp)({
            dateTimeIso: fromDateTime.toISO(),
            granularity,
        }, cache));
    }
    const recurrence = (0, checkRecurrence_1.checkRecurrence)(eventStartLineRegexMatch, lengthAtIndex, i);
    if (recurrence) {
        context.ranges.push(recurrence.range);
        context.ranges.push(colonRange(Types_1.RangeType.Recurrence));
    }
    else {
        context.ranges.push(colonRange(Types_1.RangeType.DateRange));
    }
    const dateRange = new Types_1.DateRangePart(fromDateTime, endDateTime, datePart, dateRangeInText, eventStartLineRegexMatch[regex_1.eventTextMatchIndex], recurrence);
    if (canCacheRange) {
        cache?.ranges.set(datePart, {
            fromDateTimeIso: fromDateTime.toISO(),
            toDateTimeIso: endDateTime.toISO(),
        });
    }
    return dateRange;
}
exports.getDateRangeFromCasualRegexMatch = getDateRangeFromCasualRegexMatch;
