"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTimeline = exports.parse = exports.parseDateRange = void 0;
// import { Sort } from "./Sort";
const Types_1 = require("./Types");
const regex_1 = require("./regex");
const getDateRangeFromCasualRegexMatch_1 = require("./dateRange/getDateRangeFromCasualRegexMatch");
const getDateRangeFromEDTFRegexMatch_1 = require("./dateRange/getDateRangeFromEDTFRegexMatch");
const Cache_1 = require("./Cache");
const checkEvent_1 = require("./lineChecks/checkEvent");
const ParsingContext_1 = require("./ParsingContext");
const checkNonEvents_1 = require("./lineChecks/checkNonEvents");
function parseDateRange(dateRangeString) {
    const parsingContext = new ParsingContext_1.ParsingContext();
    let dateRange = (0, getDateRangeFromEDTFRegexMatch_1.getDateRangeFromEDTFRegexMatch)(dateRangeString, 0, [], parsingContext);
    if (!dateRange) {
        dateRange = (0, getDateRangeFromCasualRegexMatch_1.getDateRangeFromCasualRegexMatch)(dateRangeString, 0, [], parsingContext);
    }
    return dateRange;
}
exports.parseDateRange = parseDateRange;
function parse(timelineString, cache) {
    if (!timelineString) {
        return { timelines: [(0, Types_1.emptyTimeline)()] };
    }
    const lines = timelineString.split("\n");
    let lengthAtIndex = [];
    for (let i = 0; i < lines.length; i++) {
        if (i === 0) {
            lengthAtIndex.push(0);
        }
        lengthAtIndex.push(1 + lines[i].length + lengthAtIndex[lengthAtIndex.length - 1] || 0);
    }
    const timelines = [];
    let index = 0;
    if (cache === true) {
        cache = new Cache_1.Cache();
    }
    do {
        const timeline = parseTimeline(lines, lengthAtIndex, index, cache);
        index = timeline.metadata.endLineIndex + 1;
        timelines.push(timeline);
    } while (index < lines.length);
    return { timelines: timelines, cache };
}
exports.parse = parse;
function checkNewPage(line, i, startLineIndex, lengthAtIndex, context) {
    if (line.match(regex_1.PAGE_BREAK_REGEX)) {
        while (context.foldableSections.length) {
            context.finishFoldableSection(i, lengthAtIndex[i] + line.length);
        }
        return context.toTimeline(lengthAtIndex, startLineIndex, i, lengthAtIndex[i] - 1);
    }
}
function parseTimeline(lines, lengthAtIndex, startLineIndex = 0, cache) {
    const context = new ParsingContext_1.ParsingContext();
    for (let i = startLineIndex; i < lines.length; i++) {
        const line = lines[i];
        if ((0, checkNonEvents_1.checkNonEvents)(line, i, lengthAtIndex, context)) {
            continue;
        }
        const completedTimeline = checkNewPage(line, i, startLineIndex, lengthAtIndex, context);
        if (completedTimeline) {
            return completedTimeline;
        }
        // TODO: Setting i from the result of checkEvent here allows us to not needlessly reparse lines,
        // but also breaks folding of comments under events
        i = (0, checkEvent_1.checkEvent)(line, lines, i, lengthAtIndex, context, cache);
    }
    // if (context.eventSubgroup) {
    //   context.events.push(context.eventSubgroup);
    // }
    return context.toTimeline(lengthAtIndex, startLineIndex, lines.length - 1, 
    // As this is the last timeline, return the length of the whole string
    lengthAtIndex[lines.length - 1] + lines[lines.length - 1].length);
}
exports.parseTimeline = parseTimeline;
