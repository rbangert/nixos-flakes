"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEventNode = exports.arrayValue = exports.eventValue = exports.blankClone = exports.ranges = exports.eventRange = exports.flatMap = exports.flat = exports.getLast = exports.get = exports.push = exports.iterate = exports.walk = exports.toArray = void 0;
const Node_1 = require("./Node");
const Types_1 = require("./Types");
const toArray = (node) => {
    const array = [];
    for (const pathAndNode of (0, exports.iterate)(node)) {
        array.push(pathAndNode);
    }
    return array;
};
exports.toArray = toArray;
const walk = (node, path, fn) => {
    fn(node, path);
    if (!(0, exports.isEventNode)(node)) {
        const arr = node.value;
        for (let i = 0; i < arr.length; i++) {
            (0, exports.walk)(arr[i], [...path, i], fn);
        }
    }
};
exports.walk = walk;
const iterate = (node) => {
    return {
        [Symbol.iterator]() {
            let stack = [node];
            let path = [];
            let pathInverted = [];
            return {
                next() {
                    const ourPath = [...pathInverted];
                    const value = stack.shift();
                    if (Array.isArray(value?.value)) {
                        stack = value.value.concat(stack);
                        path.push(value.value.length);
                        pathInverted.push(0);
                    }
                    else {
                        path[path.length - 1] -= 1;
                        pathInverted[pathInverted.length - 1] += 1;
                        while (path[path.length - 1] <= 0) {
                            path.pop();
                            path[path.length - 1] -= 1;
                            pathInverted.pop();
                            pathInverted[pathInverted.length - 1] += 1;
                        }
                    }
                    return {
                        done: !value,
                        value: {
                            path: ourPath,
                            node: value,
                        },
                    };
                },
            };
        },
    };
};
exports.iterate = iterate;
const push = (node, onto, path, tail) => {
    if (!path || !path.length) {
        if (Array.isArray(onto.value)) {
            onto.value.push(node);
            if (Array.isArray(node.value)) {
                return {
                    path: [onto.value.length - 1, node.value.length],
                    tail,
                };
            }
            else {
                return {
                    path: [onto.value.length - 1],
                    tail: node,
                };
            }
        }
        else {
            throw new Error("Can't push onto event node");
        }
    }
    else {
        const { tail: newTail, path: newPath } = (0, exports.push)(node, onto.value[path[0]], path.slice(1), tail);
        return {
            path: [path[0], ...newPath],
            tail: newTail,
        };
    }
};
exports.push = push;
const get = (root, path) => {
    if (!path.length) {
        return root;
    }
    // If it wasn't us and we don't have any nodes to offer,
    // return undefined
    const arr = root.value;
    if (!arr.length || arr.length - 1 < path[0]) {
        return undefined;
    }
    return (0, exports.get)(arr[path[0]], path.slice(1));
};
exports.get = get;
const getLast = (node) => {
    if (!Array.isArray(node.value)) {
        return { node, path: [] };
    }
    if (!node.value.length) {
        return { node, path: [] };
    }
    const indexOfLast = node.value.length - 1;
    const result = (0, exports.getLast)(node.value[indexOfLast]);
    return {
        node: result.node,
        path: [indexOfLast, ...result.path],
    };
};
exports.getLast = getLast;
const flat = (node) => (0, exports.flatMap)(node, (n) => n);
exports.flat = flat;
const flatMap = (node, mapper) => {
    if ((0, exports.isEventNode)(node)) {
        return [mapper(node)];
    }
    return node.value.flatMap((n) => (0, exports.flatMap)(n, mapper));
};
exports.flatMap = flatMap;
const eventRange = (e) => (0, Types_1.toDateRange)(e.dateRangeIso);
exports.eventRange = eventRange;
const ranges = (root) => {
    if (!root.value) {
        return undefined;
    }
    if (!Array.isArray(root.value)) {
        return {
            ...(0, exports.eventRange)(root.value),
            maxFrom: (0, exports.eventRange)(root.value).fromDateTime,
        };
    }
    const childRanges = root.value.reduce((prev, curr) => {
        const currRange = (0, exports.ranges)(curr);
        if (!prev) {
            return currRange;
        }
        if (!currRange) {
            return currRange;
        }
        const min = +currRange.fromDateTime < +prev.fromDateTime
            ? currRange.fromDateTime
            : prev.fromDateTime;
        const max = +currRange.toDateTime > +prev.toDateTime
            ? currRange.toDateTime
            : prev.toDateTime;
        const maxFrom = +currRange.maxFrom > +prev.maxFrom ? currRange.maxFrom : prev.maxFrom;
        const range = {
            fromDateTime: min,
            toDateTime: max,
            maxFrom,
        };
        return range;
    }, undefined);
    return childRanges;
};
exports.ranges = ranges;
const blankClone = (node) => {
    if (!Array.isArray(node.value)) {
        return new Node_1.Node(node.value);
    }
    const clone = new Node_1.Node([]);
    clone.startExpanded = node.startExpanded;
    clone.tags = node.tags;
    clone.title = node.title;
    clone.style = node.style;
    clone.rangeInText = node.rangeInText;
    // @ts-ignore
    return clone;
};
exports.blankClone = blankClone;
const eventValue = (node) => {
    return node?.value;
};
exports.eventValue = eventValue;
const arrayValue = (node) => {
    return node?.value;
};
exports.arrayValue = arrayValue;
const isEventNode = (node
// @ts-ignore
) => {
    return !Array.isArray(node.value);
};
exports.isEventNode = isEventNode;
